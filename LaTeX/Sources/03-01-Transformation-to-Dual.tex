\section{Transformation to Polygonal Dual}
\label{sect:transformation-to-polygonal-dual}

In this step of the pipeline, we take an embedded cluster graph $G_\text{emb}$ and form a polygonal dual of $G_\text{emb}$, our initial map graph $G_\text{init}$.

Let us discuss the relationship between $G_\text{emb}$ and $G_\text{init}$ a bit more. Recall from \cref{chap:preliminaries} that the weak dual of a plane graph is its dual without the vertex corresponding to its outer face. Using this terminology, given $G_\text{init}$, which is a hole-free polygonal dual of the plane graph $G_\text{emb}$, we can smooth out the degree-2 vertices in $G_\text{init}$ and form its weak dual to get back $G_\text{emb}$, as illustrated in the following figure:
%
\begin{figure}[H]
	\centering
	\subfigure[]{\includegraphics[height=90px]{Resources/Transformation-PolygonalDual-Dual.pdf}\label{subfig:transformation-polygonal-dual-dual}}
	\quad
	\subfigure[]{\includegraphics[height=90px]{Resources/Transformation-PolygonalDual-Smoothed.pdf}\label{subfig:transformation-polygonal-dual-smoothed}}
	\quad
	\subfigure[]{\includegraphics[height=90px]{Resources/Transformation-PolygonalDual-Primal.pdf}\label{subfig:transformation-polygonal-dual-primal}}
	\caption{A polygonal dual $G_\text{init}$ of some plane graph $G_\text{emb}$ (a), $G_\text{init}$ with its degree-2 vertices smoothed out (b), and the smoothed graphs's weak dual, $G_\text{emb}$ again (c).}
	\label{fig:transformation-polygonal-dual}
\end{figure}

We can also formalize the other direction, namely how to get from \cref{subfig:transformation-polygonal-dual-primal} back to \cref{subfig:transformation-polygonal-dual-dual}. To do so, we need the concept of an augmented dual:
%
\begin{definition}
	The \emph{augmented dual} $G^+$ of a plane graph $G$ is the plane multigraph obtained by first placing a new vertex in the outer face of $G$, connecting it to all vertices on the outer face, in order, without introducing edge crossings, and then forming its dual.
	\label{def:augmented-dual}
\end{definition}

\Cref{fig:transformation-augmented-dual} illustrates how the augmented dual is formed.
%
\begin{figure}[H]
	\centering
	\subfigure[]{\includegraphics[height=90px]{Resources/Transformation-AugmentedDual-Primal.pdf}}
	\quad
	\subfigure[]{\includegraphics[height=90px]{Resources/Transformation-AugmentedDual-Augmented.pdf}}
	\quad
	\subfigure[]{\includegraphics[height=90px]{Resources/Transformation-AugmentedDual-Everything.pdf}}
	\quad
	\subfigure[]{\includegraphics[height=90px]{Resources/Transformation-AugmentedDual-Dual.pdf}}
	\caption{Step-by-step representation of forming a plane graph $G$ (a)'s augmented dual. We add the helper vertex and edges in the outer face in red (b) and form the regular dual in blue (c). (d) shows just the augmented dual $G^+$.}
	\label{fig:transformation-augmented-dual}
\end{figure}

Note that analogous to the regular dual, the weak dual of the augmented dual of a plane graph $G$ is $G$ again, \ie{} $(G^+)^- = G$. With this definition in plane, we make the following observation:

\begin{corollary}
	A polygonal dual of an internally triangulated plane graph $G$ is a straight-line planar embedding of a subdivision of its augmented dual $G^+$.
\end{corollary}



\paragraph{Theoretical Results}

But do we have to subdivide edges of the augmented dual of our embedded cluster graph $G_\text{emb}$ in order to get a valid polygonal dual of $G_\text{emb}$? Although the augmented dual $G_\text{emb}^+$ is plane by definition, it is not immediately obvious that there exists a planar straight-line embedding of $G_\text{emb}^+$ \emdash{} and that's what we need for it to be a polygonal contact representation.

In our case, however, $G_\text{emb}^+$ is simple, \ie{} there are no loops or multiple adjacencies. Recall that $G_\text{emb}$ is 2-connected and internally triangulated. Adding the helper vertex in the outer face of $G_\text{emb}$ and connecting it to all vertices on the outer face therefore creates a fully triangulated, simple graph. In a simple triangulated graph, there are no two edges that are incident to the same faces (only those would create multiple adjacencies when forming the dual) and no edges that have the same face on both sides (only those would create loops when forming the dual) either. The augmented dual $G_\text{emb}^+$ is therefore simple and, according to Fáry's theorem \cite{fary1948straight}, there exists a planar straight-line embedding of $G_\text{emb}^+$ respecting its original combinatorial embedding.

In addition to having a planar straight-line embedding, $G_\text{emb}^+$ is also a cubic graph, \ie{} one in which all vertices have degree 3. This is because $G_\text{emb}$ with the helper vertex is a triangulated graph, meaning every face is incident to exactly three edges, which turns into every vertex being incident to exactly three edges when forming the dual. According to the results of Thomassen \cite{thomassen1992plane}, $G_\text{emb}^+$ is therefore area-universal. This means that regardless of the concrete face weights that $G_\text{emb}$ prescribes, there exists a planar straight-line embedding of $G_\text{emb}^+$ realizing those weights/areas.

Even without subdividing edges in $G_\text{emb}^+$, we could therefore choose the initial map graph $G_\text{init}$ in such a way that it has perfect statistical accuracy already. Such an embedding of $G_\text{emb}^+$ is non-trivial to compute though and creates undesired region shapes according to our other quality metrics. Instead, we provide a very simple algorithm that subdivides all edges of the augmented dual once and leaves us with enough degrees of freedom to optimize for other quality metrics in \cref{sect:drawing-the-polygonal-dual}.



\paragraph{Algorithm Overview}

The underlying idea is as follows: Given an embedded cluster graph $G_\text{emb}$, we place vertices on edges of the outer face of $G_\text{emb}$ (those edges bound additional triangular faces after adding the helper vertex in the process of forming the augmented dual) and inside the internal faces of $G_\text{emb}$. We then connect these vertices if their corresponding faces are incident. Connecting two vertices may require additional subdivision vertices in order not to introduce edge crossings \emdash{} we use a single subdivision vertex per edge.

% and was independently proved by Wagner \cite{wagner1936bemerkungen} and Stein \cite{stein1951convex}.
In a preliminary step, we tweak the embedding of $G_\text{emb}$ to use straight-line edges. As mentioned before, such an embedding exists for every plane graph according to Fáry's theorem \cite{fary1948straight}. There exist numerous popular algorithms to construct such an embedding such as Tutte's method \cite{tutte1963draw}, the shift method \cite{fraysseix1990draw}, or the Schnyder realizer method \cite{schnyder1990embedding}. \tamara{is this Tutte the algorithm with exponential area you meant?}



\clearpage
\paragraph{Algorithm Implementation}

\begin{algorithm}[H]
  \caption{Transformation to Polygonal Dual}
  \label{algo:transformation-to-dual}
  \SetKwData{Endpoints}{endpoints}
  \SetKwFunction{Appending}{appending}
  \SetArgSty{textrm}
  \vspace{5pt}
  \KwData{planar straight-line embedding of 2-connected, internally triangulated graph $G_\text{emb}$}
  \KwResult{planar straight-line embedding of 1-subdivision of augmented dual $G_\text{init}$ of $G_\text{emb}$}
  \vspace{10pt}
  create empty output graph $G_\text{init}$\;
  \ForEach{inner face $f$ in $G_\text{emb}$}{
    \label{line:transformation-loop1-start}
    add \quoted{inner face vertex} $v_f$ to $G_\text{init}$\; \label{line:transformation-innerfacevertex}
    position $v_f$ at barycenter of $f$ in $G_\text{emb}$ \label{line:transformation-barycenter1}\;
    \label{line:transformation-loop1-end}
  }
  \ForEach{edge $\{u,v\}$ in $G_\text{emb}$}{
    \label{line:transformation-loop2-start}
  	\If{$\{u,v\}$ is incident to two different internal faces $f, g$ in $G_\text{emb}$ \label{line:transformation-incidentfacelookup1}}{
  	  add \quoted{subdivision vertex} $v_\text{sub}$ to $G_\text{init}$\; \label{line:transformation-subdivisionvertex1}
  	  position $v_\text{sub}$ at midpoint of ${\{u,v\}}$ in $G_\text{emb}$\;
  	  add edge between $v_f$ and $v_\text{sub}$ to $G_\text{init}$\;
  	  add edge between $v_\text{sub}$ and $v_g$ to $G_\text{init}$\;
  	}
  	\ElseIf{$\{u,v\}$ is incident to a single internal face $f$ in $G_\text{emb}$ \label{line:transformation-incidentfacelookup2}}{
  	  add \quoted{outer edge vertex} $v_{\{u,v\}}$ to $G_\text{init}$\; \label{line:transformation-outeredgevertex}
  	  position $v_{\{u,v\}}$ at midpoint of ${\{u,v\}}$ in $G_\text{emb}$\;
  	  add \quoted{subdivision vertex} $v_\text{sub}$ to $G_\text{init}$\; \label{line:transformation-subdivisionvertex2}
  	  position $v_\text{sub}$ at midpoint of barycenter of $f$ and midpoint of ${\{u,v\}}$ in $G_\text{emb}$ \label{line:transformation-barycenter2}\;
  	  add edge between $v_{\{u,v\}}$ and $v_\text{sub}$ to $G_\text{init}$\;
  	  add edge between $v_\text{sub}$ and $v_f$ to $G_\text{init}$\;
  	}
  	\label{line:transformation-loop2-end}
  }
  \ForEach{incident edges $\{\{u,v\},\{v,w\}\}$ on outer face of $G_\text{emb}$}{
    \label{line:transformation-loop3-start}
    add \quoted{subdivision vertex} $v_\text{sub}$ to $G_\text{init}$\; \label{line:transformation-subdivisionvertex3}
    position $v_\text{sub}$ at position of $v$ in $G_\text{emb}$\;
    add edge between $v_{\{u,v\}}$ and $v_\text{sub}$ to $G_\text{init}$\;
    add edge between $v_\text{sub}$ and $v_{\{v,w\}}$ to $G_\text{init}$\;
    \label{line:transformation-loop3-end}
  }
  \ForEach{vertex $u$ in $G_\text{emb}$ \label{line:transformation-enumeratevertices}}{
    \label{line:transformation-loop4-start}
    $\Endpoints \gets ()$\;
    \ForEach{adjacent pair $(v,w)$ of neighbors of $u$ (according to embedding) \label{line:transformation-enumerateedges}}{
      \If{$u,v,w$ is a triangular face $f$ with positive area in $G_\text{emb}$ \label{line:transformation-checktriangle}}{
        append $v_f$ to \Endpoints\;
      }
      \Else{
        append $v_{\{u,v\}}$ to \Endpoints\;
        append $v_{\{u,w\}}$ to \Endpoints\;
      }
    }
    \ForEach{adjacent pair $(v,w)$ in \Endpoints \label{line:transformation-insertsubdivisions}}{
      insert subdivision vertex connecting $v$ to $w$ between $v$ and $w$ in \Endpoints\;
    }
    define $f_u$ as face on \Endpoints\;
    set weight of $f_u$ to weight of $u$ in $G_\text{emb}$\;
    \label{line:transformation-loop4-end}
  }
%  \ForEach{edge $\{u,v\}$ in $G_\text{emb}$}{
%    \label{line:transformation-loop5-start}
%    set weight of adjacency between $f_u$ and $f_v$ to weight of $\{u,v\}$ in $G_\text{emb}$\;
%    \label{line:transformation-loop5-end}
%  }
  \Return $G_\text{init}$
\end{algorithm}
\vfill



\paragraph{Algorithm Correctness}

To show the algorithm's correctness, we work with a helper graph, the \emph{augmented graph} $G_\text{aug}$, that can be obtained from $G_\text{emb}$ by adding a new helper vertex in the outer face of $G_\text{emb}$ and connecting it to all vertices on the outer face of $G_\text{emb}$, in order, without introducing edge crossings. This is the same graph as used in the definition of the augmented dual in \cref{def:augmented-dual}. Therefore $G_\text{aug}^* = G_\text{emb}^+$.

The polygonal dual of $G_\text{emb}$ produced by \cref{algo:transformation-to-dual} consists of five kinds of vertices: inner face vertices (\cref{line:transformation-innerfacevertex}), outer edge vertices (\cref{line:transformation-outeredgevertex}), subdivision vertices between two inner face vertices (\cref{line:transformation-subdivisionvertex1}), subdivision vertices between an inner face vertex and an outer edge vertex (\cref{line:transformation-subdivisionvertex2}), and subdivision vertices between two outer edge vertex (\cref{line:transformation-subdivisionvertex3}). The inner face and outer edge vertices correspond to faces in the augmented graph and have degree 3, the subdivision vertices are essentially bends in the dual edges of the augmented graph and therefore have degree 2. The following figure illustrates an example:
%
\begin{figure}[H]
	\centering
	\subfigure[]{\includegraphics[height=70mm]{Resources/Transformation-Algorithm-Primal.pdf}\label{subfig:transformation-algorithm-primal}}
	\quad
	\subfigure[]{\includegraphics[height=70mm]{Resources/Transformation-Algorithm-Augmented.pdf}\label{subfig:transformation-algorithm-augmented}}
	\quad
	\subfigure[]{\includegraphics[height=70mm]{Resources/Transformation-Algorithm-Dual.pdf}\label{subfig:transformation-algorithm-dual}}
	\caption{An embedded cluster graph $G_\text{emb}$ (a), its augmented graph $G_\text{aug}$ (b), and its polygonal dual $G_\text{init}$ as produced by \cref{algo:transformation-to-dual} (c).}
	\label{fig:transformation-algorithm}
\end{figure}

Vertices in $G_\text{emb}^+$ are created for two following two scenarios:
%
\begin{itemize}
	\item Every inner face $f$ of $G_\text{emb}$ induces a corresponding vertex $v_f$ in $G_\text{emb}^+$. We create these vertices in \cref{line:transformation-innerfacevertex}.
	\item Every outer edge $\{u,v\}$ of $G_\text{emb}$ forms an additional triangular face in $G_\text{aug}$ (one with the helper vertex) and therefore induces a corresponding vertex $v_{\{u,v\}}$ in $G_\text{emb}^+$. We create these vertices in \cref{line:transformation-outeredgevertex}.
\end{itemize}

Every edge $\{u,v\}$ in $G_\text{emb}$ induces a dual edge in $G_\text{emb}^+$. Let us go over the different kinds of edges we have and how we add them to $G_\text{emb}^+$ while guaranteeing the planarity of the embedding:
%
\begin{itemize}
	\item Internal edges, \ie{} edges of $G_\text{emb}$ that do not lie on its outer face: These edges are incident to two internal faces $f, g$ of $G_\text{emb}$. Their dual edges in $G_\text{emb}^+$ therefore connect the vertices $v_f$ and $v_g$. We draw these dual edges with a bend in \cref{line:transformation-subdivisionvertex1}.
	\item Edges $\{u,v\}$ that lie on the outer face of $G_\text{emb}$: These edges are incident to an internal face $f$ of $G_\text{emb}$ and a new triangular face with the helper vertex in $G_\text{aug}$. In $G_\text{emb}^+$, their dual edges therefore connect the vertices $v_f$ and $v_{\{u,v\}}$. We could draw these dual edges without a bend, but add a bend for consistency's sake in \cref{line:transformation-subdivisionvertex2}.
	\item Helper edges $\{v,\cdot\}$ that are added to vertices $v$ on the outer face of $G_\text{emb}$ in $G_\text{aug}$: These edges are incident to two new triangular faces in $G_\text{aug}$, namely the faces formed using $\{u,v\}$ and $\{v,w\}$, assuming $u$ and $w$ are the two neighbors of $v$ on the outer face of $G_\text{emb}$. Their dual edges in $G_\text{emb}^+$ therefore connect the vertices $v_{\{u,v\}}$ and $v_{\{v,w\}}$. We draw these dual edges with a bend in \cref{line:transformation-subdivisionvertex3}.
\end{itemize}

Due to our choice of bend locations, the generated embedding is planar. This is because all edges together partition the segments from the faces' barycenters to their incident edges' midpoints and the boundary of the outer face. However, since we use the vertices on the outer face of $G_\text{emb}$ as bend locations, no vertex may appear on the outer face more than once and $G_\text{emb}$ must therefore be 2-connected.

Once the algorithm has computed $G_\text{init}$, we construct an explicit representation of its faces. We do so for $G_\text{emb}^+$ first (loop in \cref{line:transformation-enumerateedges}) and then insert the subdivision vertices (loop in \cref{line:transformation-insertsubdivisions}). The face in $G_\text{emb}^+$ that corresponds to a vertex $v$ of $G_\text{emb}$ is bounded by vertices corresponding to internal faces of $G_\text{emb}$ that contain $v$, plus the vertices corresponding to the additional triangular faces in $G_\text{aug}$ in case $v$ lies on outer face of $G_\text{emb}$. By iterating over adjacent pairs $(e_1, e_2)$ of incident edges in counterclockwise order, we can tell if $e_1$ and $e_2$ bound an internal face of $G_\text{emb}$ or if, in the case of vertices on the outer face of $G_\text{emb}$, the edges wrap around on the outside. For the wraparound case, the area sign check in \cref{line:transformation-checktriangle} is important, because $u,v,w$ might still form a triangle, albeit one with negative area, as is the case for vertex $d$ in the example from \cref{fig:transformation-algorithm}.



\paragraph{Algorithm Runtime}

To compute the input graph's faces, we replace every edge with two inversely oriented, directed edges. We then repeatedly pick any unmarked edge and form a directed cycle by following the next outgoing edge according to the embedding, marking the edges as we go. Once all edges have been marked, we have found all faces. The outer face is the only face with negative area. This can be implemented in $\bigTheta{\abs{V_\text{in}} + \abs{E_\text{in}}}$.

The input graph has $\bigTheta{\abs{V_\text{in}}}$ internal faces and they are all triangles, therefore we can compute their barycenter in $\bigTheta{1}$ each (\cref{line:transformation-barycenter1}, \cref{line:transformation-barycenter2}). By keeping track of of which faces an edge of the input graph is incident to while computing the faces as outlined above, we allow for $\bigTheta{1}$ lookups in \cref{line:transformation-incidentfacelookup1} and \cref{line:transformation-incidentfacelookup2}. The loop in \crefrange{line:transformation-loop1-start}{line:transformation-loop1-end} therefore runs in $\bigTheta{\abs{V_\text{in}}}$, the loop in \crefrange{line:transformation-loop2-start}{line:transformation-loop2-end} in $\bigTheta{\abs{E_\text{in}}}$, and the loop in \crefrange{line:transformation-loop3-start}{line:transformation-loop3-end} in $\bigTheta{\abs{E_\text{in}}}$.

The loop in \crefrange{line:transformation-loop4-start}{line:transformation-loop4-end} processes every vertex once in \cref{line:transformation-enumeratevertices} and and every edge twice \cref{line:transformation-enumerateedges}. We can check if the vertices $u,v,w$ form a triangle in constant time (\cref{line:transformation-checktriangle}) by checking if there's an edge between $v$ and $w$. Considering each of the $\bigTheta{\abs{V_\text{in}} + \abs{E_\text{in}}}$ vertices of the generated graph appears in \code{endpoints} in no more than two iterations of the loop in \crefrange{line:transformation-loop4-start}{line:transformation-loop4-end} and all those vertices have degree 3, we can find their shared neighbor in constant time and implement the entire loop to run in $\bigTheta{\abs{V_\text{in}} + \abs{E_\text{in}}}$.

%By keeping track of which faces in the generated graph correspond to which vertices in the source graph in \crefrange{line:transformation-loop4-start}{line:transformation-loop4-end}, the loop in \crefrange{line:transformation-loop5-start}{line:transformation-loop5-end} runs in $\bigTheta{\abs{V_\text{in}} + \abs{E_\text{in}}}$.

The entire algorithm can therefore be implemented to run in $\bigTheta{\abs{V_\text{in}} + \abs{E_\text{in}}}$.
