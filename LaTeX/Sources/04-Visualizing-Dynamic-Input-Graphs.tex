\chapter{Visualizing Dynamic Input Graphs}
\label{chap:visualizing-dynamic-input-graphs}

Extending the approach discussed in the previous section to dynamic input graphs is challenging primarily because we must try to preserve the viewer's mental map as the underlying data changes over time.
We want the visualization at different points in time to be similar enough so that the viewer can clearly tell what parts have changed \cite{mashima2011visualizing}, yet allow for the required changes in geography and topology.
Still, changes between visualizations at consecutive points in time should minimize movement and allow for smooth animations therebetween.

The pipeline for static inputs discussed in the previous section does not satisfy these requirements.
Running through the entire pipeline with a different, albeit similar, input graph, may result in a completely different visualization, destroying the viewer's mental map.
We therefore extend the pipeline in a way that allows for small, incremental changes to be propagated through the pipeline and to eventually be applied to the previous output in a way that preserves the viewer's mental map.

We extend the pipeline for static input by an incremental transformation phase.
This phase takes two inputs: A proportional map graph $G_\text{prop}$ that the pipeline previously produced as output for some cluster graph $G_\text{emb}$, and a sequence of operations on said cluster graph, that, when applied to $G_\text{emb}$, yields the cluster graph $G_\text{emb}^\prime$.
The incremental embedding phase then determines how these operations translate to a polygonal dual of $G_\text{emb}$ and applies the translated operations to $G_\text{prop}$, producing $G_\text{init}^\prime$, a (not necessarily approximately area-proportional) polygonal dual of $G_\text{emb}^\prime$.
This polygonal dual is then fed back into the drawing phase to make it approximately area-proportional and improve the local fatness of the map's regions.

\begin{figure}[H]
	\centering\includegraphics[width=0.9\textwidth]{Resources/Pipeline-Thesis-Dynamic.pdf}
	\caption{Overview of the algorithmic pipeline for dynamic input graphs.}
	\label{fig:dynamic-pipeline-thesis}
\end{figure}

Real-world applications such as visualizing a dynamic opinion network need a way to feed a sequence of operations on the embedded cluster graph into our framework.
This could be done by prepending an incremental clustering phase that translates changes to the simple input graph into changes of its embedded cluster graph.
However, such a sequence of operations is only meaningful in combination with a graph that these operations can be applied to.
One must provide the previously-produced cluster graph as additional input to the incremental clustering phase such that it can tailor its output to the cluster graph that has already been locked in in an earlier run through the pipeline.

This tweak to our pipeline is illustrated in the following figure:
%
\begin{figure}[H]
	\centering\includegraphics[width=0.9\textwidth]{Resources/Pipeline-Application-Dynamic.pdf}
	\caption{Overview of a possible algorithmic pipeline for generic applications.}
	\label{fig:dynamic-pipeline-application}
\end{figure}

Extending the pipeline to allow the propagation of small, incremental changes of the input graph has numerous benefits other than the ability to preserve the viewer's mental map:
%
\begin{itemize}
\item It allows highly efficient implementations of the incremental parts of the pipeline as only the aspects that have actually changed in the input graph or intermediate products need to be processed and propagated further along the pipeline.
\item It makes the dynamic pipeline highly parallelizable: when a later phase is processing changes, an earlier phase can already start processing new changes independently.
With our force-directed implementation of the drawing phase, we can even incorporate dynamic updates while the drawing phase is still running, even if it has not converged yet: we pause the force simulation, feed the current map graph $G_\text{prop}$ into the incremental transformation phase to incorporate the dynamic updates, and then resume the simulation with the updated map graph $G_\text{init}^\prime$ produced by the incremental transformation phase.
\item It efficiently supports dynamic input in an online setting, \ie{} a setting in which the incremental changes aren't known in advance, for example when visualizing live data.
\end{itemize}



\paragraph{Supported Operations}

Our pipeline supports numerous classes of primitive operations on the cluster graph, such as inserting and removing vertices and edges, flipping edges, or simply changing a cluster's weight.
By composing multiple primitive operations in a sequence, more drastic changes can be made to the cluster graph.
In our pipeline, the operations are applied one by one nonetheless.

The simplest operation of all is changing a vertex $v$'s weight: We simply take the previous proportional map graph $G_\text{prop}$, update the weight of the face $f_v$ corresponding to the vertex $v$, and declare that as the new initial map graph $G_\text{init}^\prime$.
$G_\text{init}^\prime$ then runs through the drawing phase again to account for the updated face weights.

Implementing the remaining operations as part of the incremental transformation is a little more challenging, and we'll discuss those in great detail in the following sections.

\clearpage
\input{Sources/04-01-Inserting-Vertices}
\clearpage
\input{Sources/04-02-Removing-Vertices}
\clearpage
\input{Sources/04-03-Flipping-Edges}
